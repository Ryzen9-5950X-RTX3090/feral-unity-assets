using BestHTTP.PlatformSupport.IL2CPP;

namespace BestHTTP.SecureProtocol.Org.BouncyCastle.Crypto.Utilities
{
	[Il2CppSetOption(Option.NullChecks, false)]
	[Il2CppSetOption(Option.ArrayBoundsChecks, false)]
	[Il2CppSetOption(Option.DivideByZeroChecks, false)]
	internal static class Pack
	{
		internal static void UInt16_To_BE(ushort n, byte[] bs)
		{
		}

		internal static void UInt16_To_BE(ushort n, byte[] bs, int off)
		{
		}

		internal static ushort BE_To_UInt16(byte[] bs)
		{
			return default(ushort);
		}

		internal static ushort BE_To_UInt16(byte[] bs, int off)
		{
			return default(ushort);
		}

		internal static byte[] UInt32_To_BE(uint n)
		{
			return null;
		}

		internal static void UInt32_To_BE(uint n, byte[] bs)
		{
		}

		internal static void UInt32_To_BE(uint n, byte[] bs, int off)
		{
		}

		internal static byte[] UInt32_To_BE(uint[] ns)
		{
			return null;
		}

		internal static void UInt32_To_BE(uint[] ns, byte[] bs, int off)
		{
		}

		internal static uint BE_To_UInt32(byte[] bs)
		{
			return default(uint);
		}

		internal static uint BE_To_UInt32(byte[] bs, int off)
		{
			return default(uint);
		}

		internal static void BE_To_UInt32(byte[] bs, int off, uint[] ns)
		{
		}

		internal static byte[] UInt64_To_BE(ulong n)
		{
			return null;
		}

		internal static void UInt64_To_BE(ulong n, byte[] bs)
		{
		}

		internal static void UInt64_To_BE(ulong n, byte[] bs, int off)
		{
		}

		internal static byte[] UInt64_To_BE(ulong[] ns)
		{
			return null;
		}

		internal static void UInt64_To_BE(ulong[] ns, byte[] bs, int off)
		{
		}

		internal static ulong BE_To_UInt64(byte[] bs)
		{
			return default(ulong);
		}

		internal static ulong BE_To_UInt64(byte[] bs, int off)
		{
			return default(ulong);
		}

		internal static void BE_To_UInt64(byte[] bs, int off, ulong[] ns)
		{
		}

		internal static void UInt16_To_LE(ushort n, byte[] bs)
		{
		}

		internal static void UInt16_To_LE(ushort n, byte[] bs, int off)
		{
		}

		internal static ushort LE_To_UInt16(byte[] bs)
		{
			return default(ushort);
		}

		internal static ushort LE_To_UInt16(byte[] bs, int off)
		{
			return default(ushort);
		}

		internal static byte[] UInt32_To_LE(uint n)
		{
			return null;
		}

		internal static void UInt32_To_LE(uint n, byte[] bs)
		{
		}

		internal static void UInt32_To_LE(uint n, byte[] bs, int off)
		{
		}

		internal static byte[] UInt32_To_LE(uint[] ns)
		{
			return null;
		}

		internal static void UInt32_To_LE(uint[] ns, byte[] bs, int off)
		{
		}

		internal static uint LE_To_UInt32(byte[] bs)
		{
			return default(uint);
		}

		internal static uint LE_To_UInt32(byte[] bs, int off)
		{
			return default(uint);
		}

		internal static void LE_To_UInt32(byte[] bs, int off, uint[] ns)
		{
		}

		internal static void LE_To_UInt32(byte[] bs, int bOff, uint[] ns, int nOff, int count)
		{
		}

		internal static uint[] LE_To_UInt32(byte[] bs, int off, int count)
		{
			return null;
		}

		internal static byte[] UInt64_To_LE(ulong n)
		{
			return null;
		}

		internal static void UInt64_To_LE(ulong n, byte[] bs)
		{
		}

		internal static void UInt64_To_LE(ulong n, byte[] bs, int off)
		{
		}

		internal static byte[] UInt64_To_LE(ulong[] ns)
		{
			return null;
		}

		internal static void UInt64_To_LE(ulong[] ns, byte[] bs, int off)
		{
		}

		internal static void UInt64_To_LE(ulong[] ns, int nsOff, int nsLen, byte[] bs, int bsOff)
		{
		}

		internal static ulong LE_To_UInt64(byte[] bs)
		{
			return default(ulong);
		}

		internal static ulong LE_To_UInt64(byte[] bs, int off)
		{
			return default(ulong);
		}

		internal static void LE_To_UInt64(byte[] bs, int off, ulong[] ns)
		{
		}

		internal static void LE_To_UInt64(byte[] bs, int bsOff, ulong[] ns, int nsOff, int nsLen)
		{
		}
	}
}
